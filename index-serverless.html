<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>å®¶ç³»å›³ä½œæˆ - Draw.ioï¼ˆã‚µãƒ¼ãƒãƒ¼ãƒ¬ã‚¹ç‰ˆï¼‰</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            display: flex;
            flex-direction: column;
        }
        header, footer {
            background: rgba(255, 255, 255, 0.95);
            padding: 14px 20px;
            box-shadow: 0 2px 10px rgba(0, 0, 0, 0.1);
            text-align: center;
        }
        h1 { color: #333; font-size: 26px; margin-bottom: 6px; }
        .subtitle { color: #666; font-size: 14px; }

        .container {
            flex: 1;
            display: flex;
            flex-direction: column;
            gap: 16px;
            padding: 16px;
        }

        .panel {
            background: rgba(255, 255, 255, 0.95);
            border-radius: 10px;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
            padding: 14px;
        }

        .button-group {
            display: flex;
            gap: 10px;
            flex-wrap: wrap;
            justify-content: center;
        }
        button {
            padding: 10px 16px;
            border: none;
            border-radius: 6px;
            color: white;
            cursor: pointer;
            font-weight: 600;
        }
        .btn-primary { background: #667eea; }
        .btn-secondary { background: #48bb78; }
        .btn-info { background: #4299e1; }

        .ped-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(150px, 1fr));
            gap: 8px;
            margin-top: 8px;
        }
        .ped-grid label { font-size: 12px; color: #555; display: block; margin-bottom: 4px; }
        .ped-grid input, .ped-grid select, #ped-output, #ped-text-input {
            width: 100%;
            padding: 8px;
            border: 1px solid #cbd5e0;
            border-radius: 6px;
            font-size: 14px;
        }

        .ped-actions { margin-top: 10px; display: flex; gap: 8px; flex-wrap: wrap; }

        .ped-table { margin-top: 10px; overflow-x: auto; }
        .ped-table table { width: 100%; border-collapse: collapse; font-size: 13px; }
        .ped-table th, .ped-table td {
            border: 1px solid #e2e8f0;
            padding: 6px;
            text-align: center;
            white-space: nowrap;
        }
        .ped-table th { background: #f7fafc; }

        .editor-container {
            flex: 0 0 auto;
            background: white;
            border-radius: 10px;
            overflow: hidden;
            box-shadow: 0 8px 16px rgba(0, 0, 0, 0.2);
            height: 78vh;
            min-height: 900px;
        }
        #drawio-frame { width: 100%; height: 100%; border: none; }

        .help { font-size: 13px; color: #444; line-height: 1.6; }
    </style>
</head>
<body>
    <header>
        <h1>ğŸŒ³ å®¶ç³»å›³ä½œæˆãƒ„ãƒ¼ãƒ«ï¼ˆã‚µãƒ¼ãƒãƒ¼ãƒ¬ã‚¹ï¼‰</h1>
        <p class="subtitle">åŒä¸€ãƒšãƒ¼ã‚¸å†…ã§ draw.io ã‚’ iframe åŸ‹ã‚è¾¼ã¿ã—ã¦å‹•ä½œã—ã¾ã™</p>
    </header>

    <div class="container">
        <div class="panel">
            <h3>ğŸ“‹ PEDå…¥åŠ›ï¼ˆDraw.ioèµ·å‹•å‰ï¼‰</h3>
            <div class="ped-grid">
                <div><label for="fid">Family ID (FID)</label><input id="fid" value="FAM001"></div>
                <div><label for="iid">Individual ID (ID)</label><input id="iid" placeholder="I001"></div>
                <div><label for="pid">Paternal ID (çˆ¶ID)</label><input id="pid" value="0"></div>
                <div><label for="mid">Maternal ID (æ¯ID)</label><input id="mid" value="0"></div>
                <div>
                    <label for="sex">Sex (æ€§åˆ¥)</label>
                    <select id="sex"><option value="1">1=ç”·æ€§</option><option value="2">2=å¥³æ€§</option><option value="0">0=ä¸æ˜</option></select>
                </div>
                <div><label for="pheno">Phenotype (è¡¨ç¾å‹)</label><input id="pheno" value="1"></div>
                <div><label for="age">Age (å¹´é½¢)</label><input id="age" value=""></div>
            </div>

            <div class="ped-actions">
                <button class="btn-primary" onclick="addPedEntry()">1äººè¿½åŠ </button>
                <button class="btn-secondary" onclick="loadSamplePedigree()">3ä¸–ä»£7äººã‚µãƒ³ãƒ—ãƒ«</button>
                <button class="btn-secondary" onclick="loadSample2Gen4()">2ä¸–ä»£4äººã‚µãƒ³ãƒ—ãƒ«</button>
                <button class="btn-secondary" onclick="loadSample3Gen10()">3ä¸–ä»£10äººã‚µãƒ³ãƒ—ãƒ«</button>
                <button class="btn-secondary" onclick="loadSample4Gen20()">4ä¸–ä»£20äººã‚µãƒ³ãƒ—ãƒ«</button>
                <button class="btn-info" onclick="clearPedEntries()">ã‚¯ãƒªã‚¢</button>
            </div>

            <label for="ped-text-input" style="display:block;margin-top:10px;font-size:12px;color:#555;">PEDãƒ†ã‚­ã‚¹ãƒˆè²¼ã‚Šä»˜ã‘ï¼ˆã‚¿ãƒ–/ã‚¹ãƒšãƒ¼ã‚¹åŒºåˆ‡ã‚Šï¼‰</label>
            <div style="margin:6px 0 8px 0;font-size:12px;color:#555;line-height:1.5;">
                ã‚«ãƒ©ãƒ é †: <strong>1.å®¶ç³»ID 2.SampleID 3.çˆ¶SampleID 4.æ¯SampleID 5.æ€§åˆ¥ 6.è¡¨ç¾å‹ 7.å¹´é½¢</strong><br>
                1.å®¶ç³»ID<br>
                2.SampleID<br>
                3.çˆ¶SampleID : ä¸æ˜ã®å ´åˆã¯ <code>0</code> ã‚’ã”æŒ‡å®šãã ã•ã„<br>
                4.æ¯SampleID : ä¸æ˜ã®å ´åˆã¯ <code>0</code> ã‚’ã”æŒ‡å®šãã ã•ã„<br>
                5.æ€§åˆ¥ : ç”·æ€§ï¼1ã€å¥³æ€§ï¼2 ã¨è¨˜è¼‰ã—ã¦ãã ã•ã„ã€‚ç©ºç™½ã®å ´åˆã¯ã€æ€§åˆ¥ä¸æ˜=ãƒ€ã‚¤ãƒ¤ã§è¡¨ç¤ºã—ã¾ã™<br>
                6.è¡¨ç¾å‹ : æœªç™ºç—‡ï¼1ã€ç™ºç—‡ï¼2 ã¨è¨˜è¼‰ã—ã¦ãã ã•ã„ã€‚ç©ºç™½ã®å ´åˆã¯æœªç™ºç—‡æ‰±ã„ã«ãªã‚Šã¾ã™<br>
                7.å¹´é½¢ : ç©ºç™½ã¨ã—ã¦ã‚‚å•é¡Œã‚ã‚Šã¾ã›ã‚“ã€‚å…„å¼Ÿã¯å¹´é½¢é †ã«ã‚½ãƒ¼ãƒˆã—ã¾ã™
            </div>
            <textarea id="ped-text-input" rows="5" placeholder="FAM001	I001	0	0	1	1	72
FAM001	I002	0	0	2	1	70"></textarea>
            <div class="ped-actions">
                <button class="btn-info" onclick="importPedText(true)">è²¼ã‚Šä»˜ã‘å†…å®¹ã§ç½®ãæ›ãˆã‚‹</button>
                <button class="btn-info" onclick="importPedText(false)">è²¼ã‚Šä»˜ã‘å†…å®¹ã‚’è¿½åŠ ã™ã‚‹</button>
            </div>

            <div class="ped-table">
                <table>
                    <thead><tr><th>FID</th><th>ID</th><th>çˆ¶ID</th><th>æ¯ID</th><th>æ€§åˆ¥</th><th>è¡¨ç¾å‹</th><th>å¹´é½¢</th><th>å‰Šé™¤</th></tr></thead>
                    <tbody id="ped-tbody"></tbody>
                </table>
            </div>

            <label for="ped-output" style="display:block;margin-top:8px;font-size:12px;color:#555;">PEDå½¢å¼ãƒ—ãƒ¬ãƒ“ãƒ¥ãƒ¼</label>
            <textarea id="ped-output" rows="5" readonly></textarea>
        </div>

        <div class="panel">
            <div class="button-group">
                <button class="btn-primary" onclick="openGeneratedPedigree()">PEDã‹ã‚‰å®¶ç³»å›³ç”Ÿæˆã—ã¦é–‹ã</button>
                <button class="btn-secondary" onclick="saveAsXml()">SaveAsXML</button>
                <button class="btn-secondary" onclick="saveAsSvg()">SVGã¨ã—ã¦ä¿å­˜ã™ã‚‹</button>
            </div>
        </div>

        <div class="editor-container">
            <div id="connect-tip" style="display:none;margin:10px 10px 0 10px;padding:8px 10px;background:#fff3cd;border:1px solid #ffe69c;border-radius:6px;color:#664d03;font-size:13px;"></div>
            <iframe id="drawio-frame" src=""></iframe>
        </div>
    </div>

    <footer>
        <p>Powered by diagrams.net</p>
    </footer>

    <script>
        const pedEntries = [];
        let pendingXmlDownload = false;
        let currentXmlSpinKey = null;
        function getLibraryUrl() {
            if (window.location.protocol.startsWith('http')) {
                    return `${getSiteBaseUrl()}/family-shapes-library.xml`;
            }
            return null;
        }

        function getLocalDrawioBaseUrl() {
            if (window.location.protocol.startsWith('http')) {
                    return `${getSiteBaseUrl()}/drawio-webapp/index.html`;
            }
            return null;
        }

            function getSiteBaseUrl() {
                const path = window.location.pathname || '/';
                const basePath = path.replace(/\/[^/]*$/, '');
                return `${window.location.origin}${basePath}`;
            }

        function getDrawioUrl(params = '') {
            const libUrl = getLibraryUrl();
            const clibs = libUrl ? `&clibs=U${encodeURIComponent(libUrl)}` : '';
            const query = `?embed=1&ui=min&proto=json&spin=1&lang=ja&splash=0&local=1&libraries=1${clibs}${params}`;
            const localBase = getLocalDrawioBaseUrl();
            if (localBase) return `${localBase}${query}`;
            return `https://app.diagrams.net/${query}`;
        }

        function getExternalDrawioUrl(params = '') {
            const libUrl = getLibraryUrl();
            const clibs = libUrl ? `&clibs=U${encodeURIComponent(libUrl)}` : '';
            return `https://app.diagrams.net/?ui=atlas&lang=ja&splash=0&libraries=1${clibs}${params}`;
        }

        function openExternalDrawioTab() {
            const url = getExternalDrawioUrl('');
            window.open(url, '_blank', 'noopener,noreferrer');
        }

        function openExternalDrawioWithXml(modelXml) {
            const fullUrl = getExternalDrawioUrl(`&xml=${encodeURIComponent(modelXml)}`);
            window.open(fullUrl, '_blank', 'noopener,noreferrer');
        }

        async function openGeneratedPedigree() {
            if (pedEntries.length === 0) {
                alert('PEDãƒ‡ãƒ¼ã‚¿ãŒç©ºã§ã™ã€‚ã¾ãšã€Œ1äººè¿½åŠ ã€ã¾ãŸã¯ã€Œ3ä¸–ä»£7äººã‚µãƒ³ãƒ—ãƒ«ã€ã‚’å®Ÿè¡Œã—ã¦ãã ã•ã„ã€‚');
                return;
            }
            const modelXml = buildPedigreeMxGraphModel(pedEntries);
            await launchDrawioWithOptionalXml(modelXml);
        }

        async function launchDrawioWithOptionalXml(modelXml) {
            const iframe = document.getElementById('drawio-frame');
            const tip = document.getElementById('connect-tip');

            if (tip) {
                tip.style.display = 'none';
            }

            iframe.onload = function () {
                if (!modelXml) return;
                const payload = JSON.stringify({ action: 'load', autosave: 1, xml: modelXml });
                setTimeout(() => iframe.contentWindow.postMessage(payload, '*'), 1200);
                setTimeout(() => iframe.contentWindow.postMessage(payload, '*'), 2600);
            };

            iframe.src = getDrawioUrl(`&launch=${Date.now()}`);
        }

        function addPedEntry() {
            const entry = {
                fid: document.getElementById('fid').value.trim() || 'FAM001',
                id: document.getElementById('iid').value.trim(),
                fatherId: document.getElementById('pid').value.trim() || '0',
                motherId: document.getElementById('mid').value.trim() || '0',
                sex: document.getElementById('sex').value,
                phenotype: document.getElementById('pheno').value.trim() || '1',
                age: document.getElementById('age').value.trim()
            };

            if (!entry.id) { alert('Individual ID (ID) ã‚’å…¥åŠ›ã—ã¦ãã ã•ã„ã€‚'); return; }
            if (pedEntries.some(r => r.id === entry.id)) { alert('åŒã˜IDãŒæ—¢ã«å­˜åœ¨ã—ã¾ã™ã€‚'); return; }

            pedEntries.push(entry);
            renderPedEntries();
            document.getElementById('iid').value = '';
            document.getElementById('pid').value = '0';
            document.getElementById('mid').value = '0';
            document.getElementById('sex').value = '1';
            document.getElementById('pheno').value = '1';
            document.getElementById('age').value = '';
        }

        function removePedEntry(index) {
            pedEntries.splice(index, 1);
            renderPedEntries();
        }

        function clearPedEntries() {
            pedEntries.length = 0;
            renderPedEntries();
        }

        function importPedText(replaceExisting) {
            const text = (document.getElementById('ped-text-input').value || '').trim();
            if (!text) {
                alert('PEDãƒ†ã‚­ã‚¹ãƒˆã‚’è²¼ã‚Šä»˜ã‘ã¦ãã ã•ã„ã€‚');
                return;
            }

            const lines = text.split(/\r?\n/);
            const imported = [];
            const existingIds = new Set(replaceExisting ? [] : pedEntries.map(item => item.id));

            for (let lineIndex = 0; lineIndex < lines.length; lineIndex++) {
                const line = lines[lineIndex].trim();
                if (!line || line.startsWith('#')) continue;

                const columns = line.split(/\s+/);
                if (columns.length < 6) {
                    alert(`PEDå½¢å¼ã‚¨ãƒ©ãƒ¼: ${lineIndex + 1}è¡Œç›®ã¯6åˆ—ä»¥ä¸Šå¿…è¦ã§ã™ã€‚`);
                    return;
                }

                const record = {
                    fid: columns[0],
                    id: columns[1],
                    fatherId: columns[2] || '0',
                    motherId: columns[3] || '0',
                    sex: columns[4] || '0',
                    phenotype: columns[5] || '1',
                    age: columns[6] || ''
                };

                if (!record.id) {
                    alert(`PEDå½¢å¼ã‚¨ãƒ©ãƒ¼: ${lineIndex + 1}è¡Œç›®ã®IDãŒç©ºã§ã™ã€‚`);
                    return;
                }
                if (existingIds.has(record.id)) {
                    alert(`é‡è¤‡IDã‚¨ãƒ©ãƒ¼: ${record.id} ãŒé‡è¤‡ã—ã¦ã„ã¾ã™ã€‚`);
                    return;
                }

                existingIds.add(record.id);
                imported.push(record);
            }

            if (replaceExisting) {
                pedEntries.length = 0;
            }
            pedEntries.push(...imported);
            renderPedEntries();
        }

        function loadSamplePedigree() {
            pedEntries.length = 0;
            pedEntries.push(
                { fid: 'FAM001', id: 'I001', fatherId: '0',    motherId: '0',    sex: '1', phenotype: '1', age: '78' },
                { fid: 'FAM001', id: 'I002', fatherId: '0',    motherId: '0',    sex: '2', phenotype: '1', age: '75' },
                { fid: 'FAM001', id: 'I003', fatherId: '0',    motherId: '0',    sex: '1', phenotype: '1', age: '74' },
                { fid: 'FAM001', id: 'I004', fatherId: '0',    motherId: '0',    sex: '2', phenotype: '1', age: '72' },
                { fid: 'FAM001', id: 'I005', fatherId: 'I001', motherId: 'I002', sex: '1', phenotype: '1', age: '50' },
                { fid: 'FAM001', id: 'I006', fatherId: 'I003', motherId: 'I004', sex: '2', phenotype: '1', age: '48' },
                { fid: 'FAM001', id: 'I007', fatherId: 'I005', motherId: 'I006', sex: '1', phenotype: '2', age: '24' }
            );
            renderPedEntries();
        }

        function loadSample2Gen4() {
            pedEntries.length = 0;
            pedEntries.push(
                { fid: 'FAM002', id: 'I001', fatherId: '0',    motherId: '0',    sex: '1', phenotype: '1', age: '42' },
                { fid: 'FAM002', id: 'I002', fatherId: '0',    motherId: '0',    sex: '2', phenotype: '1', age: '40' },
                { fid: 'FAM002', id: 'I003', fatherId: 'I001', motherId: 'I002', sex: '1', phenotype: '1', age: '14' },
                { fid: 'FAM002', id: 'I004', fatherId: 'I001', motherId: 'I002', sex: '2', phenotype: '2', age: '10' }
            );
            renderPedEntries();
        }

        function loadSample3Gen10() {
            pedEntries.length = 0;
            pedEntries.push(
                { fid: 'FAM003', id: 'I001', fatherId: '0',    motherId: '0',    sex: '1', phenotype: '1', age: '76' },
                { fid: 'FAM003', id: 'I002', fatherId: '0',    motherId: '0',    sex: '2', phenotype: '1', age: '73' },
                { fid: 'FAM003', id: 'I003', fatherId: '0',    motherId: '0',    sex: '1', phenotype: '1', age: '74' },
                { fid: 'FAM003', id: 'I004', fatherId: '0',    motherId: '0',    sex: '2', phenotype: '1', age: '71' },
                { fid: 'FAM003', id: 'I005', fatherId: 'I001', motherId: 'I002', sex: '1', phenotype: '1', age: '52' },
                { fid: 'FAM003', id: 'I006', fatherId: 'I001', motherId: 'I002', sex: '2', phenotype: '1', age: '49' },
                { fid: 'FAM003', id: 'I007', fatherId: 'I003', motherId: 'I004', sex: '1', phenotype: '2', age: '50' },
                { fid: 'FAM003', id: 'I008', fatherId: 'I003', motherId: 'I004', sex: '2', phenotype: '1', age: '46' },
                { fid: 'FAM003', id: 'I009', fatherId: 'I005', motherId: 'I008', sex: '1', phenotype: '1', age: '26' },
                { fid: 'FAM003', id: 'I010', fatherId: 'I005', motherId: 'I008', sex: '2', phenotype: '2', age: '22' }
            );
            renderPedEntries();
        }

        function loadSample4Gen20() {
            pedEntries.length = 0;
            pedEntries.push(
                { fid: 'FAM004', id: 'I001', fatherId: '0',    motherId: '0',    sex: '1', phenotype: '1', age: '82' },
                { fid: 'FAM004', id: 'I002', fatherId: '0',    motherId: '0',    sex: '2', phenotype: '1', age: '80' },
                { fid: 'FAM004', id: 'I003', fatherId: '0',    motherId: '0',    sex: '1', phenotype: '1', age: '81' },
                { fid: 'FAM004', id: 'I004', fatherId: '0',    motherId: '0',    sex: '2', phenotype: '1', age: '79' },
                { fid: 'FAM004', id: 'I005', fatherId: 'I001', motherId: 'I002', sex: '1', phenotype: '1', age: '52' },
                { fid: 'FAM004', id: 'I006', fatherId: 'I003', motherId: 'I004', sex: '2', phenotype: '1', age: '49' },
                { fid: 'FAM004', id: 'I007', fatherId: 'I005', motherId: 'I006', sex: '1', phenotype: '2', age: '24' },

                { fid: 'FAM004', id: 'I008', fatherId: '0',    motherId: '0',    sex: '1', phenotype: '1', age: '83' },
                { fid: 'FAM004', id: 'I009', fatherId: '0',    motherId: '0',    sex: '2', phenotype: '1', age: '81' },
                { fid: 'FAM004', id: 'I010', fatherId: '0',    motherId: '0',    sex: '1', phenotype: '1', age: '80' },
                { fid: 'FAM004', id: 'I011', fatherId: '0',    motherId: '0',    sex: '2', phenotype: '1', age: '78' },
                { fid: 'FAM004', id: 'I012', fatherId: 'I008', motherId: 'I009', sex: '2', phenotype: '1', age: '50' },
                { fid: 'FAM004', id: 'I013', fatherId: 'I010', motherId: 'I011', sex: '1', phenotype: '1', age: '47' },
                { fid: 'FAM004', id: 'I014', fatherId: 'I012', motherId: 'I013', sex: '2', phenotype: '1', age: '22' },

                { fid: 'FAM004', id: 'I015', fatherId: 'I007', motherId: 'I014', sex: '1', phenotype: '1', age: '12' },
                { fid: 'FAM004', id: 'I016', fatherId: 'I007', motherId: 'I014', sex: '2', phenotype: '1', age: '10' },
                { fid: 'FAM004', id: 'I017', fatherId: 'I007', motherId: 'I014', sex: '1', phenotype: '2', age: '8' },
                { fid: 'FAM004', id: 'I018', fatherId: 'I007', motherId: 'I014', sex: '2', phenotype: '1', age: '6' },
                { fid: 'FAM004', id: 'I019', fatherId: 'I007', motherId: 'I014', sex: '1', phenotype: '1', age: '4' },
                { fid: 'FAM004', id: 'I020', fatherId: 'I007', motherId: 'I014', sex: '2', phenotype: '1', age: '2' }
            );
            renderPedEntries();
        }

        function renderPedEntries() {
            const tbody = document.getElementById('ped-tbody');
            tbody.innerHTML = pedEntries.map((row, index) => `
                <tr>
                    <td>${row.fid}</td>
                    <td>${row.id}</td>
                    <td>${row.fatherId}</td>
                    <td>${row.motherId}</td>
                    <td>${row.sex}</td>
                    <td>${row.phenotype}</td>
                    <td>${row.age || ''}</td>
                    <td><button onclick="removePedEntry(${index})" style="padding:4px 8px;">å‰Šé™¤</button></td>
                </tr>
            `).join('');

            document.getElementById('ped-output').value = pedEntries
                .map(r => `${r.fid} ${r.id} ${r.fatherId} ${r.motherId} ${r.sex} ${r.phenotype} ${r.age || ''}`.trim())
                .join('\n');
        }

        function saveAsXml() {
            const iframe = document.getElementById('drawio-frame');
            if (!iframe.src) { alert('å…ˆã«draw.ioã‚’é–‹ã„ã¦ãã ã•ã„ã€‚'); return; }

            pendingXmlDownload = true;
            currentXmlSpinKey = `xml-${Date.now()}`;

            iframe.contentWindow.postMessage(JSON.stringify({ action: 'save', exit: false }), '*');
            setTimeout(() => {
                if (!pendingXmlDownload) return;
                iframe.contentWindow.postMessage(JSON.stringify({ action: 'export', format: 'xml', spinKey: currentXmlSpinKey }), '*');
            }, 1500);
        }

        function saveAsSvg() {
            const iframe = document.getElementById('drawio-frame');
            if (!iframe.src) { alert('å…ˆã«draw.ioã‚’é–‹ã„ã¦ãã ã•ã„ã€‚'); return; }

            iframe.contentWindow.postMessage(JSON.stringify({ action: 'export', format: 'svg', spinKey: `svg-${Date.now()}` }), '*');
        }

        function buildPedigreeMxGraphModel(entries) {
            const peopleById = Object.fromEntries(entries.map(person => [person.id, person]));
            const levelMemo = {};

            function getParentPairKey(person) {
                if (!person) return '';
                const fatherId = person.fatherId || '0';
                const motherId = person.motherId || '0';
                if (fatherId === '0' || motherId === '0') return '';
                return `${fatherId}|${motherId}`;
            }

            function getAgeNumber(person) {
                const value = Number(person && person.age);
                return Number.isFinite(value) ? value : null;
            }

            function compareSiblingAware(a, b) {
                const pairA = getParentPairKey(a);
                const pairB = getParentPairKey(b);
                if (pairA && pairA === pairB) {
                    const ageA = getAgeNumber(a);
                    const ageB = getAgeNumber(b);
                    if (ageA !== null && ageB !== null && ageA !== ageB) {
                        return ageB - ageA;
                    }
                }
                return a.id.localeCompare(b.id);
            }

            function getLevel(personId, stack = new Set()) {
                if (!personId || personId === '0' || !peopleById[personId]) return 0;
                if (levelMemo[personId] !== undefined) return levelMemo[personId];
                if (stack.has(personId)) return 0;
                stack.add(personId);

                const person = peopleById[personId];
                const fatherLevel = person.fatherId && person.fatherId !== '0' ? getLevel(person.fatherId, stack) : 0;
                const motherLevel = person.motherId && person.motherId !== '0' ? getLevel(person.motherId, stack) : 0;
                stack.delete(personId);

                const hasKnownParent = (person.fatherId && person.fatherId !== '0' && peopleById[person.fatherId]) ||
                                       (person.motherId && person.motherId !== '0' && peopleById[person.motherId]);
                levelMemo[personId] = hasKnownParent ? Math.max(fatherLevel, motherLevel) + 1 : 0;
                return levelMemo[personId];
            }

            entries.forEach(person => getLevel(person.id));

            const levels = {};
            entries.forEach(person => {
                const level = levelMemo[person.id] || 0;
                if (!levels[level]) levels[level] = [];
                levels[level].push(person);
            });
            Object.values(levels).forEach(group => group.sort(compareSiblingAware));

            const pageWidth = 1600;
            const symbolYStart = 60;
            const rowGap = 240;
            const colGap = 180;
            const symbolSize = 80;

            const geometryById = {};
            const rootCells = ['<mxCell id="0"/>', '<mxCell id="1" parent="0"/>'];
            const edgeCells = [];
            const nodeCells = [];
            let nextCellId = 2;

            function shapeStyle(person) {
                const affected = person.phenotype === '2';
                if (person.sex === '1') return `rounded=0;whiteSpace=wrap;html=1;strokeColor=#000000;strokeWidth=2;fillColor=${affected ? '#000000' : '#ffffff'};`;
                if (person.sex === '2') return `ellipse;whiteSpace=wrap;html=1;aspect=fixed;strokeColor=#000000;strokeWidth=2;fillColor=${affected ? '#000000' : '#ffffff'};`;
                return `rhombus;whiteSpace=wrap;html=1;strokeColor=#000000;strokeWidth=2;fillColor=${affected ? '#000000' : '#ffffff'};`;
            }

            Object.keys(levels).map(Number).sort((a, b) => a - b).forEach(level => {
                const group = levels[level];
                let centers = [];

                if (level === 0) {
                    const count = group.length;
                    const rowWidth = symbolSize + Math.max(0, count - 1) * colGap;
                    const startX = Math.round((pageWidth - rowWidth) / 2);
                    centers = group.map((_, index) => startX + index * colGap + symbolSize / 2);
                } else {
                    const minGap = 140;
                    const preferred = group.map(person => {
                        const father = person.fatherId && person.fatherId !== '0' ? geometryById[person.fatherId] : null;
                        const mother = person.motherId && person.motherId !== '0' ? geometryById[person.motherId] : null;
                        let preferredCenter = pageWidth / 2;
                        if (father && mother) preferredCenter = (father.centerX + mother.centerX) / 2;
                        else if (father) preferredCenter = father.centerX;
                        else if (mother) preferredCenter = mother.centerX;
                        return { person, preferredCenter };
                    });

                    preferred.sort((a, b) => {
                        if (a.preferredCenter !== b.preferredCenter) return a.preferredCenter - b.preferredCenter;
                        return compareSiblingAware(a.person, b.person);
                    });
                    const assigned = [];
                    let prev = -Infinity;
                    preferred.forEach(item => {
                        const value = Math.max(item.preferredCenter, prev + minGap);
                        assigned.push({ person: item.person, center: value });
                        prev = value;
                    });

                    const minCenter = Math.min(...assigned.map(a => a.center));
                    const maxCenter = Math.max(...assigned.map(a => a.center));
                    const shift = (pageWidth / 2) - ((minCenter + maxCenter) / 2);

                    const centerById = {};
                    assigned.forEach(item => { centerById[item.person.id] = item.center + shift; });
                    centers = group.map(person => centerById[person.id]);
                }

                group.forEach((person, index) => {
                    const centerX = centers[index];
                    const x = Math.round(centerX - symbolSize / 2);
                    const y = symbolYStart + level * rowGap;
                    geometryById[person.id] = { x, y, centerX: x + symbolSize / 2, topY: y, midY: y + symbolSize / 2 };

                    const symbolId = nextCellId++;
                    const textId = nextCellId++;
                    const phenotypeLabel = person.phenotype === '2'
                        ? 'Affected'
                        : (person.phenotype === '1' ? 'Unaffected' : `P:${person.phenotype}`);
                    const ageLabel = person.age ? `, Age:${person.age}` : '';
                    nodeCells.push(`<mxCell id="${symbolId}" value="" style="${shapeStyle(person)}" vertex="1" parent="1"><mxGeometry x="${x}" y="${y}" width="${symbolSize}" height="${symbolSize}" as="geometry"/></mxCell>`);
                    nodeCells.push(`<mxCell id="${textId}" value="${escapeXml(`${person.id} (${phenotypeLabel}${ageLabel})`)}" style="text;html=1;strokeColor=none;fillColor=none;align=center;verticalAlign=top;whiteSpace=wrap;rounded=0;fontSize=18;" vertex="1" parent="1"><mxGeometry x="${x - 30}" y="${y + symbolSize + 6}" width="150" height="34" as="geometry"/></mxCell>`);
                });
            });

            const marriageMap = new Map();
            entries.forEach(person => {
                if (person.fatherId !== '0' && person.motherId !== '0' && geometryById[person.fatherId] && geometryById[person.motherId]) {
                    const key = [person.fatherId, person.motherId].sort().join('|');
                    if (!marriageMap.has(key)) marriageMap.set(key, { fatherId: person.fatherId, motherId: person.motherId });
                }
            });

            const coupleMidMap = new Map();
            marriageMap.forEach((pair, key) => {
                const father = geometryById[pair.fatherId];
                const mother = geometryById[pair.motherId];
                const level = levelMemo[pair.fatherId] || 0;
                const rowPeople = levels[level] || [];
                const minX = Math.min(father.centerX, mother.centerX);
                const maxX = Math.max(father.centerX, mother.centerX);
                const hasInterveningNode = rowPeople.some(person => {
                    if (person.id === pair.fatherId || person.id === pair.motherId) return false;
                    const node = geometryById[person.id];
                    if (!node) return false;
                    return node.centerX > minX && node.centerX < maxX;
                });

                if (!hasInterveningNode) {
                    const y1 = Math.min(father.midY, mother.midY) - 4;
                    const y2 = y1 + 8;
                    edgeCells.push(`<mxCell id="${nextCellId++}" value="" style="endArrow=none;html=1;strokeWidth=3;strokeColor=#000000;" edge="1" parent="1"><mxGeometry relative="1" as="geometry"><mxPoint x="${father.centerX}" y="${y1}" as="sourcePoint"/><mxPoint x="${mother.centerX}" y="${y1}" as="targetPoint"/></mxGeometry></mxCell>`);
                    edgeCells.push(`<mxCell id="${nextCellId++}" value="" style="endArrow=none;html=1;strokeWidth=3;strokeColor=#000000;" edge="1" parent="1"><mxGeometry relative="1" as="geometry"><mxPoint x="${father.centerX}" y="${y2}" as="sourcePoint"/><mxPoint x="${mother.centerX}" y="${y2}" as="targetPoint"/></mxGeometry></mxCell>`);
                    coupleMidMap.set(key, { midX: (father.centerX + mother.centerX) / 2, y: y2 });
                } else {
                    const fatherBottomY = father.topY + symbolSize;
                    const motherBottomY = mother.topY + symbolSize;
                    const baseBottomY = Math.max(fatherBottomY, motherBottomY);
                    const yUpper = baseBottomY + 56;
                    const yLower = yUpper + 8;

                    edgeCells.push(`<mxCell id="${nextCellId++}" value="" style="endArrow=none;html=1;strokeWidth=3;strokeColor=#000000;" edge="1" parent="1"><mxGeometry relative="1" as="geometry"><mxPoint x="${father.centerX}" y="${fatherBottomY}" as="sourcePoint"/><mxPoint x="${father.centerX}" y="${yUpper}" as="targetPoint"/></mxGeometry></mxCell>`);
                    edgeCells.push(`<mxCell id="${nextCellId++}" value="" style="endArrow=none;html=1;strokeWidth=3;strokeColor=#000000;" edge="1" parent="1"><mxGeometry relative="1" as="geometry"><mxPoint x="${mother.centerX}" y="${motherBottomY}" as="sourcePoint"/><mxPoint x="${mother.centerX}" y="${yUpper}" as="targetPoint"/></mxGeometry></mxCell>`);

                    edgeCells.push(`<mxCell id="${nextCellId++}" value="" style="endArrow=none;html=1;strokeWidth=3;strokeColor=#000000;" edge="1" parent="1"><mxGeometry relative="1" as="geometry"><mxPoint x="${father.centerX}" y="${yUpper}" as="sourcePoint"/><mxPoint x="${mother.centerX}" y="${yUpper}" as="targetPoint"/></mxGeometry></mxCell>`);
                    edgeCells.push(`<mxCell id="${nextCellId++}" value="" style="endArrow=none;html=1;strokeWidth=3;strokeColor=#000000;" edge="1" parent="1"><mxGeometry relative="1" as="geometry"><mxPoint x="${father.centerX}" y="${fatherBottomY}" as="sourcePoint"/><mxPoint x="${father.centerX}" y="${yLower}" as="targetPoint"/></mxGeometry></mxCell>`);
                    edgeCells.push(`<mxCell id="${nextCellId++}" value="" style="endArrow=none;html=1;strokeWidth=3;strokeColor=#000000;" edge="1" parent="1"><mxGeometry relative="1" as="geometry"><mxPoint x="${mother.centerX}" y="${motherBottomY}" as="sourcePoint"/><mxPoint x="${mother.centerX}" y="${yLower}" as="targetPoint"/></mxGeometry></mxCell>`);
                    edgeCells.push(`<mxCell id="${nextCellId++}" value="" style="endArrow=none;html=1;strokeWidth=3;strokeColor=#000000;" edge="1" parent="1"><mxGeometry relative="1" as="geometry"><mxPoint x="${father.centerX}" y="${yLower}" as="sourcePoint"/><mxPoint x="${mother.centerX}" y="${yLower}" as="targetPoint"/></mxGeometry></mxCell>`);

                    coupleMidMap.set(key, { midX: (father.centerX + mother.centerX) / 2, y: yLower });
                }
            });

            const childrenByCouple = new Map();
            entries.forEach(person => {
                if (person.fatherId !== '0' && person.motherId !== '0' && geometryById[person.id]) {
                    const key = [person.fatherId, person.motherId].sort().join('|');
                    if (!childrenByCouple.has(key)) childrenByCouple.set(key, []);
                    childrenByCouple.get(key).push(geometryById[person.id]);
                }
            });

            childrenByCouple.forEach((children, key) => {
                const coupleMid = coupleMidMap.get(key);
                if (!coupleMid || children.length === 0) return;

                children.sort((a, b) => a.centerX - b.centerX);
                const minChildX = children[0].centerX;
                const maxChildX = children[children.length - 1].centerX;
                const minChildTopY = Math.min(...children.map(child => child.topY));
                const siblingY = minChildTopY - 44;

                edgeCells.push(`<mxCell id="${nextCellId++}" value="" style="endArrow=none;html=1;strokeWidth=3;strokeColor=#000000;" edge="1" parent="1"><mxGeometry relative="1" as="geometry"><mxPoint x="${coupleMid.midX}" y="${coupleMid.y}" as="sourcePoint"/><mxPoint x="${coupleMid.midX}" y="${siblingY}" as="targetPoint"/></mxGeometry></mxCell>`);

                edgeCells.push(`<mxCell id="${nextCellId++}" value="" style="endArrow=none;html=1;strokeWidth=3;strokeColor=#000000;" edge="1" parent="1"><mxGeometry relative="1" as="geometry"><mxPoint x="${minChildX}" y="${siblingY}" as="sourcePoint"/><mxPoint x="${maxChildX}" y="${siblingY}" as="targetPoint"/></mxGeometry></mxCell>`);

                children.forEach(child => {
                    edgeCells.push(`<mxCell id="${nextCellId++}" value="" style="endArrow=none;html=1;strokeWidth=3;strokeColor=#000000;" edge="1" parent="1"><mxGeometry relative="1" as="geometry"><mxPoint x="${child.centerX}" y="${siblingY}" as="sourcePoint"/><mxPoint x="${child.centerX}" y="${child.topY}" as="targetPoint"/></mxGeometry></mxCell>`);
                });
            });

            const graphModel = `<mxGraphModel dx="1420" dy="780" grid="1" gridSize="10" guides="1" tooltips="1" connect="1" arrows="1" fold="1" page="1" pageScale="1" pageWidth="1600" pageHeight="1200" math="0" shadow="0"><root>${rootCells.join('')}${edgeCells.join('')}${nodeCells.join('')}</root></mxGraphModel>`;
            return `<mxfile host="app.diagrams.net" modified="${new Date().toISOString()}" agent="5.0" version="24.0.0" type="device"><diagram id="pedigree" name="PED Family">${graphModel}</diagram></mxfile>`;
        }

        function escapeXml(text) {
            return String(text || '')
                .replace(/&/g, '&amp;')
                .replace(/</g, '&lt;')
                .replace(/>/g, '&gt;')
                .replace(/"/g, '&quot;')
                .replace(/'/g, '&apos;');
        }

        function dataUrlToBlob(dataUrl) {
            const raw = String(dataUrl || '');
            const m = raw.match(/^data:([^;,]+)?(;base64)?,(.*)$/s);
            if (!m) return null;
            const mime = m[1] || 'application/octet-stream';
            const isBase64 = !!m[2];
            const payload = m[3] || '';
            if (isBase64) {
                const bytes = atob(payload);
                const arr = new Uint8Array(bytes.length);
                for (let i = 0; i < bytes.length; i++) arr[i] = bytes.charCodeAt(i);
                return new Blob([arr], { type: mime });
            }
            return new Blob([decodeURIComponent(payload)], { type: mime });
        }

        function triggerDownload(blob, fileName) {
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = fileName;
            document.body.appendChild(a);
            a.click();
            a.remove();
            URL.revokeObjectURL(url);
        }

        window.addEventListener('message', async (event) => {
            if (!event.data) return;
            let msg = null;
            if (typeof event.data === 'string') {
                try { msg = JSON.parse(event.data); } catch { return; }
            } else if (typeof event.data === 'object') {
                msg = event.data;
            }
            if (!msg || !msg.event) return;

            if (msg.event === 'save' && pendingXmlDownload) {
                const xml = msg.xml || '';
                if (xml) {
                    pendingXmlDownload = false;
                    triggerDownload(new Blob([xml], { type: 'application/xml;charset=utf-8' }), `pedigree-${new Date().toISOString().replace(/[:.]/g, '-')}.drawio`);
                }
                return;
            }

            if (msg.event === 'export' && msg.data) {
                if (pendingXmlDownload && currentXmlSpinKey && msg.spinKey === currentXmlSpinKey) {
                    pendingXmlDownload = false;
                    const xmlBlob = dataUrlToBlob(msg.data) || new Blob([String(msg.data)], { type: 'application/xml;charset=utf-8' });
                    triggerDownload(xmlBlob, `pedigree-${new Date().toISOString().replace(/[:.]/g, '-')}.drawio`);
                    return;
                }

                const raw = String(msg.data);
                if (raw.startsWith('data:image/svg')) {
                    const svgBlob = dataUrlToBlob(raw);
                    if (svgBlob) {
                        triggerDownload(svgBlob, `pedigree-${new Date().toISOString().replace(/[:.]/g, '-')}.svg`);
                        return;
                    }
                }

                if (raw.startsWith('<svg')) {
                    triggerDownload(new Blob([raw], { type: 'image/svg+xml;charset=utf-8' }), `pedigree-${new Date().toISOString().replace(/[:.]/g, '-')}.svg`);
                }
            }
        });

        renderPedEntries();
    </script>
</body>
</html>
